# hw
Quero criar um comando chamado **`hw`** (de *Hello World*), que
funcione como uma **ferramenta de linha de comando (CLI)**.
A ideia √© simples: ele deve imprimir na tela um exemplo
de ‚ÄúHello, World!‚Äù na linguagem que eu especificar ou,
se n√£o houver especifica√ß√£o, na linguagem definida no
arquivo de configura√ß√£o.

Por exemplo:

* `hw -c` deve mostrar um exemplo b√°sico em **C**.
* `hw --cpp` deve mostrar um exemplo b√°sico em **C++**.

O ponto interessante √© que o programa ser√° **extens√≠vel**:
ele crescer√° √† medida que eu adicionar novos exemplos e
aprender mais linguagens.

Portanto, quero a sua ajuda para definir **qual design** devo
adotar para implementar esse programa e **em qual linguagem**
ele deve ser desenvolvido.


## Vou te passar um desenho simples, mas robusto, para que o comando seja:

* f√°cil de usar (flags curtas como `-c`, `--cpp`);
* f√°cil de estender (adicionar linguagens sem mexer no c√≥digo);
* port√°til (funciona em Linux/macOS/Windows);
* version√°vel (pode virar um √∫nico bin√°rio depois).

Abaixo est√° a proposta + um prot√≥tipo funcional.

# Design (simples e flex√≠vel)

## 1) Interface de linha de comando

* Uso b√°sico:

  * `hw -c` ‚Üí imprime ‚Äúhello world‚Äù em C
  * `hw --cpp` ‚Üí imprime em C++
  * `hw --lang rust` ou `hw -l rs` ‚Üí imprime em Rust
  * `hw` ‚Üí usa a linguagem padr√£o do config
* Sa√≠das:

  * padr√£o: imprime no `stdout`
  * opcional: `--out main.c` grava em arquivo
* Qualidade de vida:

  * `--list` mostra linguagens dispon√≠veis
  * `--edit rust` abre o template do Rust no seu editor (opcional, depois)

## 2) Onde ficam os templates

Ordem de busca (para permitir override do usu√°rio):

1. **Templates do usu√°rio**:
   `~/.local/share/hw/templates/` (Linux)
   `~/Library/Application Support/hw/templates/` (macOS)
   `%APPDATA%\hw\templates\` (Windows)
2. **Templates ‚Äúembutidos‚Äù** no programa (fallback).

Cada template √© um arquivo por linguagem, ex.: `c.tmpl`,
`cpp.tmpl`, `rust.tmpl`.

Exemplos:

* `c.tmpl`

  ```c
  #include <stdio.h>
  int main(void) {
      puts("Hello, World!");
      return 0;
  }
  ```
* `cpp.tmpl`

  ```cpp
  #include <iostream>
  int main() {
      std::cout << "Hello, World!\n";
  }
  ```

## 3) Configura√ß√£o do usu√°rio

Arquivo TOML, por exemplo:

* Linux: `~/.config/hw/config.toml`

Conte√∫do:

```toml
default_lang = "cpp"

[aliases]
c = "c"
cpp = "cpp"
cc = "cpp"
rs = "rust"
```

Regras:

* `default_lang` define a linguagem quando o usu√°rio n√£o passa flag.
* `[aliases]` mapeia abrevia√ß√µes/flags curtas para nomes de template.

  * Ex.: `-c` ‚Üí alias ‚Äúc‚Äù; `--cpp` ‚Üí alias ‚Äúcpp‚Äù.
* Preced√™ncia: flag > alias > default_lang.

## 4) Extensibilidade (sem recompilar)

* Para adicionar uma linguagem nova, o usu√°rio s√≥ precisa criar um arquivo `nova.tmpl` na pasta de templates. Pronto.
* Aliases podem ser adicionados no `config.toml`.
* Para algo ainda mais avan√ßado no futuro, voc√™ pode suportar **plugins execut√°veis**: se n√£o existir `X.tmpl`, o `hw` tenta executar `hw-X` no PATH e imprime o que ele retornar.

## 5) Linguagem de implementa√ß√£o

* **Python**: √≥timo para prototipar r√°pido (argparse, pathlib, tomllib), f√°cil de rodar no seu ambiente Linux. Depois voc√™ pode ‚Äúcongelar‚Äù em um bin√°rio com `pyinstaller`.
* **Go**: excelente para empacotar como um √∫nico bin√°rio e distribuir; bom segundo passo quando o design estabilizar.
* **Rust**: muito bom tamb√©m, mas a curva de in√≠cio √© maior para um utilit√°rio simples.

üëâ Sugest√£o pr√°tica: **comece em Python** (ganho imediato) e, quando o conjunto de features estabilizar, **porte para Go** (bin√°rio √∫nico, zero depend√™ncias).

---

# Prot√≥tipo funcional (Python 3.11+)

> Salve como `hw` (ou `hw.py`) e d√™ permiss√£o de execu√ß√£o (`chmod +x hw`).
> Ele j√° vem com C e C++ embutidos; l√™ config/aliases e templates do usu√°rio se existirem.

```python
#!/usr/bin/env python3
import argparse
import os
import sys
from pathlib import Path

# --- Util: paths por OS
def user_config_dir() -> Path:
    if sys.platform.startswith("linux"):
        return Path.home() / ".config" / "hw"
    elif sys.platform == "darwin":
        return Path.home() / "Library" / "Application Support" / "hw"
    else:
        return Path(os.environ.get("APPDATA", str(Path.home()))) / "hw"

def user_data_dir() -> Path:
    if sys.platform.startswith("linux"):
        return Path.home() / ".local" / "share" / "hw"
    elif sys.platform == "darwin":
        return Path.home() / "Library" / "Application Support" / "hw"
    else:
        return Path(os.environ.get("APPDATA", str(Path.home()))) / "hw"

# --- Carregar config TOML (Python 3.11+ tem tomllib)
def load_config():
    cfg = {"default_lang": "c", "aliases": {}}
    cfg_path = user_config_dir() / "config.toml"
    if cfg_path.exists():
        try:
            import tomllib
            data = tomllib.loads(cfg_path.read_text(encoding="utf-8"))
            if isinstance(data, dict):
                cfg.update({k: v for k, v in data.items() if k in ("default_lang", "aliases")})
                if "aliases" in cfg and cfg["aliases"] is None:
                    cfg["aliases"] = {}
        except Exception as e:
            print(f"[hw] Aviso: falha ao ler {cfg_path}: {e}", file=sys.stderr)
    return cfg

# --- Templates embutidos (fallback)
EMBEDDED = {
    "c": """#include <stdio.h>
int main(void) {
    puts("Hello, World!");
    return 0;
}
""",
    "cpp": """#include <iostream>
int main() {
    std::cout << "Hello, World!\\n";
}
""",
    "rust": """fn main() {
    println!("Hello, World!");
}
""",
    "python": """print("Hello, World!")
""",
}

# --- Carregar template de arquivo do usu√°rio, se existir
def load_user_template(lang: str) -> str | None:
    # hw/templates/<lang>.tmpl
    base = user_data_dir() / "templates"
    candidates = [
        base / f"{lang}.tmpl",
        base / f"{lang}.txt",
    ]
    for p in candidates:
        if p.exists():
            return p.read_text(encoding="utf-8")
    return None

def resolve_lang(args, cfg):
    # 1) flag expl√≠cita --lang
    if args.lang:
        return args.lang
    # 2) flags curtas do tipo --cpp, -c, etc.: mapeadas por aliases
    # mapeio a presen√ßa de flags booleanas
    # exemplo: --cpp vira args.cpp = True
    alias_hit = None
    for k, v in cfg.get("aliases", {}).items():
        # se o alias for usado como --<k> (ex.: --cpp), argparse registra True:
        if getattr(args, k.replace("-", "_"), False):
            alias_hit = v
            break
    if alias_hit:
        return alias_hit
    # 3) default do config
    return cfg.get("default_lang", "c")

def available_languages(cfg):
    # uni√£o de embutidos + templates do usu√°rio
    langs = set(EMBEDDED.keys())
    tdir = user_data_dir() / "templates"
    if tdir.exists():
        for p in tdir.iterdir():
            if p.is_file() and p.suffix in (".tmpl", ".txt"):
                langs.add(p.stem)
    # aliases tamb√©m contam como ‚Äúatalhos‚Äù, mas n√£o como linguagem em si
    return sorted(langs)

def main():
    cfg = load_config()

    parser = argparse.ArgumentParser(
        prog="hw",
        description="Imprime um Hello World na linguagem escolhida."
    )
    parser.add_argument("-l", "--lang", help="nome da linguagem (ex.: c, cpp, rust, python)")
    parser.add_argument("--list", action="store_true", help="lista linguagens dispon√≠veis")
    parser.add_argument("--out", help="salva a sa√≠da em arquivo")
    # aliases de exemplo: -c e --cpp (voc√™ pode aumentar via config.toml)
    # Dica: mantenha em sincronia com seu config.toml
    parser.add_argument("-c", dest="c", action="store_true", help="atalho para C (alias)")
    parser.add_argument("--cpp", dest="cpp", action="store_true", help="atalho para C++ (alias)")

    # tamb√©m adiciona dinamicamente aliases definidos no config (para flags longas)
    for alias in cfg.get("aliases", {}).keys():
        if alias in ("c", "cpp"):  # j√° adicionados acima
            continue
        # cria flags longas: --rs, --zig, etc.
        parser.add_argument(f"--{alias}", dest=alias.replace("-", "_"), action="store_true",
                            help=f"atalho para linguagem mapeada em '{alias}' no config")

    args = parser.parse_args()

    if args.list:
        langs = available_languages(cfg)
        print("Linguagens dispon√≠veis:")
        for l in langs:
            print(f" - {l}")
        return 0

    lang = resolve_lang(args, cfg)

    # tenta user template primeiro
    text = load_user_template(lang)
    if text is None:
        # cai para embutido
        text = EMBEDDED.get(lang)

    if text is None:
        print(f"[hw] ERRO: linguagem '{lang}' n√£o encontrada. Use --list para ver op√ß√µes.", file=sys.stderr)
        return 1

    if args.out:
        Path(args.out).write_text(text, encoding="utf-8")
        # mensagem simples para UX
        print(f"[hw] Arquivo gerado: {args.out}")
    else:
        print(text, end="")

    return 0

if __name__ == "__main__":
    sys.exit(main())
```

## Config e templates do usu√°rio (exemplos)

1. Crie `~/.config/hw/config.toml`:

```toml
default_lang = "cpp"

[aliases]
c = "c"
cpp = "cpp"
rs = "rust"
py = "python"
```

2. Crie `~/.local/share/hw/templates/rust.tmpl` (Linux):

```rust
fn main() {
    println!("Hello, World!");
}
```

Agora:

* `hw` ‚Üí C++ (porque `default_lang = "cpp"`)
* `hw -c` ‚Üí C
* `hw --cpp` ‚Üí C++
* `hw --rs` ‚Üí Rust (via alias ‚Üí ‚Äúrust‚Äù)
* `hw --lang python` ‚Üí Python
* `hw --list` ‚Üí lista tudo que est√° embutido + seus arquivos `.tmpl`.

---

# Caminho de evolu√ß√£o

* **Autocompletar** (bash/zsh/fish) para `--lang` e aliases.
* **`--edit <lang>`**: abre o template no editor padr√£o (`$EDITOR`).
* **Plugins execut√°veis**: se n√£o achar template, tenta `hw-<lang>` no PATH.
* **Go (Cobra/Viper)** ou **Rust (clap + confy)** quando quiser empacotar bin√°rio √∫nico.
* **Testes**: testar resolu√ß√£o de ordem (flag > alias > default) e fallback dos templates.

