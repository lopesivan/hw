Perfeito — adaptei o `hw.cpp` para aceitar **aliases curtos com múltiplas letras** (ex.: `-py`, `-pl`, `-rs`). A lógica agora interpreta qualquer token que comece por `-` (um hífen só) como um **alias textual inteiro** após o hífen.

Abaixo estão apenas as **partes que você precisa substituir** no arquivo que te enviei. (Se preferir, posso colar o arquivo completo já atualizado.)

---

# 1) Ajuda (atualize `print_help`)

Substitua a função `print_help` pela versão abaixo (apenas o texto mudou para documentar `-py`, `-pl`, etc.):

```cpp
static void print_help(const char* prog, const Config& cfg) {
    std::cout
        << "Usage: " << prog << " [options]\n\n"
        << "Options:\n"
        << "  -l, --lang <name>   Linguagem (ex.: c, cpp, rust, python)\n"
        << "      --list          Lista linguagens disponíveis\n"
        << "      --out <file>    Salva a saída em arquivo\n"
        << "\nAtalhos:\n"
        << "  -c                  Atalho embutido para C\n"
        << "      --cpp           Atalho embutido para C++\n"
        << "  -<alias>            Alias curto de várias letras, ex.: -py, -pl, -rs\n"
        << "  --<alias>           Alias longo, ex.: --python, --perl\n"
        << "\nAliases do config.ini ([aliases]):\n";
    if (cfg.aliases.empty()) {
        std::cout << "  (nenhum alias definido)\n";
    } else {
        for (auto& kv : cfg.aliases) {
            std::cout << "  " << kv.first << " -> " << kv.second << "\n";
        }
    }
    std::cout << "\nConfig e templates:\n"
#ifdef _WIN32
              << "  Config:    %APPDATA%\\hw\\config.ini\n"
              << "  Templates: %APPDATA%\\hw\\templates\\<lang>.tmpl\n";
#elif __APPLE__
              << "  Config:    ~/Library/Application Support/hw/config.ini\n"
              << "  Templates: ~/Library/Application Support/hw/templates/<lang>.tmpl\n";
#else
              << "  Config:    ~/.config/hw/config.ini\n"
              << "  Templates: ~/.local/share/hw/templates/<lang>.tmpl\n";
#endif
}
```

---

# 2) Parser de argumentos (substitua `parse_args`)

Esta versão mantém compatibilidade com `-c`, `--cpp`, `--lang`, etc., e **adiciona** suporte a `-py`, `-pl`, `-rs`… mapeados pelo `[aliases]` do `config.ini`.

```cpp
static Args parse_args(int argc, char** argv, const Config& cfg) {
    Args a;

    for (int i = 1; i < argc; ++i) {
        std::string tok = argv[i];

        if (tok == "-h" || tok == "--help") {
            print_help(argv[0], cfg);
            std::exit(0);
        } else if (tok == "--list") {
            a.show_list = true;
        } else if (tok == "-l" || tok == "--lang") {
            if (i+1 >= argc) { std::cerr << "[hw] Faltou argumento para " << tok << "\n"; std::exit(1); }
            a.lang = argv[++i];
        } else if (tok == "--out") {
            if (i+1 >= argc) { std::cerr << "[hw] Faltou argumento para --out\n"; std::exit(1); }
            a.out_path = argv[++i];
        }
        // ---- aliases embutidos (compat) ----
        else if (tok == "-c") {
            a.alias_hit = "c";          // atalho embutido
        } else if (tok == "--cpp") {
            a.alias_hit = "cpp";        // atalho embutido
        }
        // ---- aliases do config: forma longa --<alias> ----
        else if (starts_with(tok, "--") && tok.size() > 2) {
            std::string name = tok.substr(2); // tudo após --
            auto it = cfg.aliases.find(name);
            if (it != cfg.aliases.end()) {
                a.alias_hit = it->second;
            } else {
                // desconhecido: ignore silenciosamente (ou emita aviso se preferir)
            }
        }
        // ---- aliases do config: forma curta multi-letras -<alias> ----
        // Nota: aqui consideramos o token inteiro após o hífen como o alias textual.
        // Exemplos: -py -> "py", -pl -> "pl", -rs -> "rs".
        else if (starts_with(tok, "-") && tok.size() > 1 && tok[1] != '-') {
            std::string name = tok.substr(1); // tudo após o 1º '-'
            // Caso especial: se for apenas "l", não tratamos aqui (pois -l já foi pego acima).
            if (name != "l") {
                auto it = cfg.aliases.find(name);
                if (it != cfg.aliases.end()) {
                    a.alias_hit = it->second;
                } else {
                    // Se quiser, trate combinações POSIX (-abc) aqui, mas neste app
                    // adotamos a convenção: '-<alias textual>' inteiro (sem combinações).
                }
            }
        }
        // argumentos posicionais: ignorar
    }
    return a;
}
```

**Observação importante:** optamos por **não** suportar a semântica POSIX de “combinar várias flags de uma letra” (tipo `-abc` = `-a -b -c`). Em vez disso, **tratamos o que vier após um único hífen como um alias textual inteiro**. Assim, `-py` é um alias único (Python), e não `-p` + `-y`.

---

# 3) Como configurar os aliases multi-letra

No seu `config.ini` (Linux: `~/.config/hw/config.ini`), adicione:

```ini
default_lang = cpp

[aliases]
# curtos multi-letra:
py = python
pl = perl
rs = rust

# longos:
python = python
perl = perl
rust = rust

# se quiser manter o clássico:
c = c
cpp = cpp
```

Agora você pode executar:

```bash
# flags longas:
hw --python
hw --perl

# flags curtas multi-letra:
hw -py
hw -pl
hw -rs

# embutidos de compat:
hw -c
hw --cpp

# escolha explícita:
hw --lang python

# salvar em arquivo
hw -py --out main.py
```

---

## Dica opcional: aviso de duplicatas

Se quiser, dá pra varrer `cfg.aliases` no `main` e emitir um aviso caso o mesmo alias mapeie para linguagens diferentes (ou entre em conflito com `-c`/`--cpp`). Posso te mostrar um snippet para isso depois.

Se quiser o **`hw.cpp` completo** já com essas mudanças coladas, eu já te entrego inteiro numa mensagem só.

